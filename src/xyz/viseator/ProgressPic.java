package xyz.viseator;import org.opencv.core.*;import org.opencv.imgcodecs.Imgcodecs;import org.opencv.imgproc.Imgproc;import java.awt.image.BufferedImage;import java.awt.image.DataBufferByte;import java.util.ArrayList;import java.util.Collections;import static org.opencv.imgproc.Imgproc.*;/** * Created by viseator on 2016/11/13. */public class ProgressPic {    private static final double Y_MINLINELENGTH = 1200;    private static final int Y_THRESHOLD = 150;    private static final double Y_MAXLINEGAP = 20;    private static final int X_THRESHOLD = 0;    private static final double X_MAXLINEGAP = 11;    private static final double X_HEIGHT = 0.65;    private static final double PADDING_TOP_BOTTOM = 0;    private static final double PADDING_LEFT_RIGHT = 0.09;    private Mat srcPic;//Source Picture    private Mat rawSrcPic;//Raw Source Picture    private Mat rgbSrcPic;//Rgb Source Picture    private Mat dilateMuchPic;//Dilate Much for finding lines    private String path;    private ArrayList<Mat> blockImages;    private int tableNum;    private int colNum = -1;    private boolean singleLineMode;    private ArrayList<Double> lineXs;    private ArrayList<Double> lineYs;    private ArrayList<Double> uniqueLineXs;    private ArrayList<Double> uniqueLineYs;    private ArrayList<ArrayList<ArrayList<Mat>>> mats;    private TableInfo tableInfo;    public TableInfo progress(String path, int tableNum, boolean singleLineMode) {        this.singleLineMode = singleLineMode;        this.tableNum = tableNum;        this.path = path;        tableInfo = GetTableInfo.get(tableNum);        rawSrcPic = Imgcodecs.imread(path, Imgcodecs.CV_LOAD_IMAGE_GRAYSCALE);        rgbSrcPic = Imgcodecs.imread(path, Imgcodecs.CV_LOAD_IMAGE_COLOR);        mats = new ArrayList<>();        srcPic = rawSrcPic;        binarization();        deNoise();        findLines();        cutImagesToRows();        cutImageToCols();        convertMatsToBufferedImages();        return tableInfo;    }    private void binarization() {        Imgproc.adaptiveThreshold(srcPic, srcPic, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY_INV, 27, 10);    }    private void deNoise() {        Mat kernelErode = Imgproc.getStructuringElement(Imgproc.MORPH_ERODE, new Size(2, 2));        Imgproc.erode(srcPic, srcPic, kernelErode);        Mat kernelDilate = Imgproc.getStructuringElement(Imgproc.MORPH_DILATE, new Size(2, 2));        Imgproc.dilate(srcPic, srcPic, kernelDilate);        dilateMuchPic = new Mat();        Mat kernelDilateMuch = Imgproc.getStructuringElement(Imgproc.MORPH_DILATE, new Size(12, 12));        Imgproc.dilate(srcPic, dilateMuchPic, kernelDilateMuch);    }    private void findLines() {        lineYs = new ArrayList<>();        uniqueLineYs = new ArrayList<>();        Mat lines = new Mat();        Imgproc.HoughLinesP(dilateMuchPic, lines, 1, Math.PI / 180, Y_THRESHOLD,                Y_MINLINELENGTH, Y_MAXLINEGAP);        for (int i = 0; i < lines.rows(); i++) {            double[] points = lines.get(i, 0);            double y1, y2;            y1 = points[1];            y2 = points[3];            if (Math.abs(y1 - y2) < 30) {                lineYs.add((y1 + y2) / 2);            }        }        getUniqueLines(lineYs, uniqueLineYs, 10, 0);    }    private void cutImagesToRows() {        blockImages = new ArrayList<>();        for (int i = 0; i < uniqueLineYs.size(); i++) {            Rect rect;            double y = uniqueLineYs.get(i);            if (i != uniqueLineYs.size() - 1) {                rect = new Rect((int) (srcPic.width() * PADDING_LEFT_RIGHT),                        (int) (y + (uniqueLineYs.get(i + 1) - y) * PADDING_TOP_BOTTOM),                        (int) (srcPic.width() * (1 - PADDING_LEFT_RIGHT * 2)),                        (int) ((uniqueLineYs.get(i + 1) - y) * (1 - PADDING_TOP_BOTTOM * 2)));            } else {                rect = new Rect((int) (srcPic.width() * PADDING_LEFT_RIGHT),                        (int) (y + (srcPic.height() - y) * PADDING_TOP_BOTTOM),                        (int) (srcPic.width() * (1 - PADDING_LEFT_RIGHT * 2)),                        (int) ((srcPic.height() - y) * (1 - PADDING_TOP_BOTTOM * 2)));            }            Mat cutMat = new Mat(srcPic, rect);            blockImages.add(cutMat);        }    }    private void cutImageToCols() {        for (int position = 0; position < blockImages.size(); position++) {            Mat image = blockImages.get(position);            lineXs = new ArrayList<>();            uniqueLineXs = new ArrayList<>();            dilateMuchPic = new Mat();            Mat kernelDilateMuch = Imgproc.getStructuringElement(Imgproc.MORPH_DILATE, new Size(6, 6));            Imgproc.dilate(image, dilateMuchPic, kernelDilateMuch);            Mat lines = new Mat();            Imgproc.HoughLinesP(dilateMuchPic, lines, 0.1, Math.PI / 360, X_THRESHOLD,                    image.height() * X_HEIGHT, X_MAXLINEGAP);            for (int i = 0; i < lines.rows(); i++) {                double[] points = lines.get(i, 0);                double x1, x2;                x1 = points[0];                x2 = points[2];                if (Math.abs(x1 - x2) < 50) {                    lineXs.add((x1 + x2) / 2);                }            }            getUniqueLines(lineXs, uniqueLineXs, 10, 0);            ArrayList<Double> betterLineXs = new ArrayList<>();            filterLines(uniqueLineXs, betterLineXs, image.width());            if (betterLineXs.size() < 2 || betterLineXs.size() > 5 || image.height() < srcPic.height() * 0.015) {                continue;            }            colNum++;            cutImages(betterLineXs, image);        }    }    private void getUniqueLines(ArrayList<Double> src, ArrayList<Double> dst, int maxGap, int minNum) {        Collections.sort(src);        for (int i = 0; i < src.size(); i++) {            double sum = src.get(i);            double num = 1;            //When the distance between two lines less than 10,get the average of them            while (i != src.size() - 1 && src.get(i + 1) - src.get(i) < maxGap) {                num++;                sum = sum + src.get(i + 1);                i++;            }            if (num == 1) {                dst.add(src.get(i));            } else {                if (num > minNum) {                    dst.add(sum / num);                }            }        }    }    private void getBounds(ArrayList<Double> src, ArrayList<Double> dst, int maxGap, int minDistance) {        Collections.sort(src);        for (int i = 0; i < src.size(); i++) {            double start = src.get(i);            double end = src.get(i);            //When the distance between two lines less than 10,get the average of them            while (i != src.size() - 1 && src.get(i + 1) - src.get(i) < maxGap) {                end = src.get(i + 1);                i++;            }            if (end - start >= minDistance) {                dst.add(start);                dst.add(end);            }        }    }    private void filterLines(ArrayList<Double> src, ArrayList<Double> dst, int width) {        for (int i = 0; i < src.size(); i++) {            int recode = i;            while (i != src.size() - 1 && src.get(i + 1) - src.get(i) <                    width * tableInfo.getCols(colNum + 1).getFilterGap()) {                i++;            }            dst.add(src.get(recode));        }    }    private void cutImages(ArrayList<Double> lineXs, Mat image) {        Mat cutMat = new Mat(image, new Rect((int) (lineXs.get(tableInfo.getCols(colNum).getBoundLeft()) + 5),                0,                (int) (lineXs.get(tableInfo.getCols(colNum).getBoundRight()) -                        lineXs.get(tableInfo.getCols(colNum).getBoundLeft())) - 10, image.height()));        mats.add(cutSingleLine(cutMat));    }    private ArrayList<ArrayList<Mat>> cutSingleLine(Mat srcMat) {        ArrayList<ArrayList<Mat>> singleLines = new ArrayList<>();        ArrayList<Double> emptyRows = new ArrayList<>();        ArrayList<Double> uniqueEmptyRows = new ArrayList<>();        double[] points;        for (int row = 0; row < srcMat.rows(); row++) {            int count = 0;            for (int col = 0; col < srcMat.cols(); col++) {                points = srcMat.get(row, col);                if (points[0] == 255) {                    count++;                }            }            if (count < 3) emptyRows.add((double) row);        }        getUniqueLines(emptyRows, uniqueEmptyRows, 10, 0);        if (uniqueEmptyRows.get(0) > srcMat.height() * 0.3)            uniqueEmptyRows.add(0, 0.0);        if (uniqueEmptyRows.get(uniqueEmptyRows.size() - 1) < srcMat.height() * 0.7)            uniqueEmptyRows.add((double) (srcMat.height() - 1));        ArrayList<Mat> linesInCol = new ArrayList<>();        for (int i = 0; i < uniqueEmptyRows.size(); i++) {            if (i != uniqueEmptyRows.size() - 1) {                Mat cutMat = new Mat(srcMat, new Rect(0,                        (int) (double) uniqueEmptyRows.get(i),                        srcMat.width(),                        (int) (uniqueEmptyRows.get(i + 1) - uniqueEmptyRows.get(i))));                if (singleLineMode || tableInfo.getCols(colNum).getDataType() <= 1) {                    linesInCol.add(cutMat);                } else {                    singleLines.add(cutSingleCha(cutMat, i));                }            }        }        if (singleLineMode || tableInfo.getCols(colNum).getDataType() <= 1) singleLines.add(linesInCol);        return singleLines;    }    private ArrayList<Mat> cutSingleCha(Mat srcMat, int pos) {        ArrayList<Mat> characters = new ArrayList<>();        ArrayList<Double> emptyCols = new ArrayList<>();        ArrayList<Double> uniqueEmptyCols = new ArrayList<>();        double[] points;        for (int col = 0; col < srcMat.cols(); col++) {            int count = 0;            for (int row = 0; row < srcMat.rows(); row++) {                points = srcMat.get(row, col);                if (points[0] == 255) {                    count++;                }            }            if (count < 3) emptyCols.add((double) col);        }        getBounds(emptyCols, uniqueEmptyCols, 5, 2);        for (int i = 1; i < uniqueEmptyCols.size() - 1; i += 2) {            Mat cutMat = new Mat();            if (i < uniqueEmptyCols.size() - 3) {                if (uniqueEmptyCols.get(i + 1) - uniqueEmptyCols.get(i) < 40 &&                        uniqueEmptyCols.get(i + 3) - uniqueEmptyCols.get(i) < 55                        ) {                    cutMat = new Mat(srcMat, new Rect(uniqueEmptyCols.get(i).intValue(),                            0,                            (int) (uniqueEmptyCols.get(i + 3) - uniqueEmptyCols.get(i)),                            srcMat.height()));                    i += 2;                } else {                    cutMat = new Mat(srcMat, new Rect(uniqueEmptyCols.get(i).intValue(),                            0,                            (int) (uniqueEmptyCols.get(i + 1) - uniqueEmptyCols.get(i)),                            srcMat.height()));                }            } else if (i != uniqueEmptyCols.size() - 1) {                cutMat = new Mat(srcMat, new Rect(uniqueEmptyCols.get(i).intValue(),                        0,                        (int) (uniqueEmptyCols.get(i + 1) - uniqueEmptyCols.get(i)),                        srcMat.height()));            }            characters.add(cutMat);        }        return characters;    }    private BufferedImage convertMatToBufferedImage(Mat mat) {        BufferedImage bufferedImage = new BufferedImage(mat.width(), mat.height(), BufferedImage.TYPE_BYTE_GRAY);        byte[] data = ((DataBufferByte) bufferedImage.getRaster().getDataBuffer()).getData();        mat.get(0, 0, data);        return bufferedImage;    }    private void convertMatsToBufferedImages() {        for (int colId = 0; colId < tableInfo.getColsSize(); colId++) {            ArrayList<ArrayList<Mat>> col = mats.get(colId);            ArrayList<BufferedImage> characters = new ArrayList<>();            for (ArrayList<Mat> singleLine : col) {                for (Mat character : singleLine) {                    BufferedImage bufferedImage = convertMatToBufferedImage(character);                    characters.add(bufferedImage);                }            }            tableInfo.getCols(colId).setBufferedImages(characters);        }    }}
package xyz.viseator;import org.opencv.core.*;import org.opencv.imgcodecs.Imgcodecs;import org.opencv.imgproc.Imgproc;import java.awt.image.BufferedImage;import java.awt.image.DataBufferByte;import java.util.ArrayList;import java.util.Collections;import static org.opencv.imgproc.Imgproc.*;/** * Created by viseator on 2016/11/13. */public class ProgressPic {    //the minimum length of line when find the horizontal lines of table    private static final double Y_MINLINELENGTH = 1200;    //the threshold when find the horizontal lines of table    private static final int Y_THRESHOLD = 150;    //the max gap of the intermittent line    private static final double Y_MAXLINEGAP = 20;    //familiar with above,using in find vertical lines    private static final int X_THRESHOLD = 0;    //familiar with above,using in find vertical lines    private static final double X_MAXLINEGAP = 11;    //factor for the minimum length of line,X_MINLINELENGTH = image.height() * X_HEIGHT_FACTOR    private static final double X_HEIGHT_FACTOR = 0.65;    //padding for cut table to rows    private static final double PADDING_TOP_BOTTOM = 0;    private static final double PADDING_LEFT_RIGHT = 0.09;    private Mat srcPic;//source picture    private Mat dilateMuchPic;//dilate much for finding lines    private String path;//image path    private ArrayList<Mat> blockImages; //Store rows    private int colNum = -1; //when find a valid col:colNum++    private boolean singleLineMode;    private ArrayList<ArrayList<ArrayList<Mat>>> mats; //temp    private TableInfo tableInfo;    public TableInfo progress(String path, int tableNum, boolean singleLineMode) {        this.singleLineMode = singleLineMode;        this.path = path;        tableInfo = GetTableInfo.get(tableNum);        //read image from path using gray mode        srcPic = Imgcodecs.imread(path, Imgcodecs.CV_LOAD_IMAGE_GRAYSCALE);        mats = new ArrayList<>();//init        binarization();        deNoise();        cutImagesToRows();        cutImageToCols();        convertMatsToBufferedImages();        return tableInfo;    }    /**     * binarization the srouce picture     */    private void binarization() {        //blockSize and C are the best parameters for table        Imgproc.adaptiveThreshold(srcPic, srcPic, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY_INV, 27, 10);    }    /**     * remove the isolated point in the picture     * erode the picture to remove     * then dilate it to recover others     */    private void deNoise() {        //kernel for erode, size:the size of the erosion        Mat kernelErode = Imgproc.getStructuringElement(Imgproc.MORPH_ERODE, new Size(2, 2));        Imgproc.erode(srcPic, srcPic, kernelErode);        //kernel for dilate, size:the size off the dilation        Mat kernelDilate = Imgproc.getStructuringElement(Imgproc.MORPH_DILATE, new Size(2, 2));        Imgproc.dilate(srcPic, srcPic, kernelDilate);        //dilate much, for finding all lines        dilateMuchPic = new Mat();        Mat kernelDilateMuch = Imgproc.getStructuringElement(Imgproc.MORPH_DILATE, new Size(12, 12));        Imgproc.dilate(srcPic, dilateMuchPic, kernelDilateMuch);    }    /**     * cut images to rows and store in blockImages     */    private void cutImagesToRows() {        ArrayList<Double> lineYs = new ArrayList<>();        ArrayList<Double> uniqueLineYs = new ArrayList<>();        //lines:a special mat for find lines        Mat lines = new Mat();        //find lines and store in lines        Imgproc.HoughLinesP(dilateMuchPic, lines, 1, Math.PI / 180, Y_THRESHOLD,                Y_MINLINELENGTH, Y_MAXLINEGAP);        //get the lines information from lines and store in lineYs        for (int i = 0; i < lines.rows(); i++) {            double[] points = lines.get(i, 0);            double y1, y2;            //just need the horizontal lines            y1 = points[1];            y2 = points[3];            // if it slopes, get the average of them, store the y-coordinate            if (Math.abs(y1 - y2) < 30) {                lineYs.add ((y1 + y2) / 2);            }        }        getUniqueLines(lineYs, uniqueLineYs, 10);        blockImages = new ArrayList<>();        for (int i = 0; i < uniqueLineYs.size(); i++) {            Rect rect;            double y = uniqueLineYs.get(i);            //if not the last line            if (i != uniqueLineYs.size() - 1) {                rect = new Rect((int) (srcPic.width() * PADDING_LEFT_RIGHT),                        (int) (y + (uniqueLineYs.get(i + 1) - y) * PADDING_TOP_BOTTOM),                        (int) (srcPic.width() * (1 - PADDING_LEFT_RIGHT * 2)),                        (int) ((uniqueLineYs.get(i + 1) - y) * (1 - PADDING_TOP_BOTTOM * 2)));            } else {                //the last line                rect = new Rect((int) (srcPic.width() * PADDING_LEFT_RIGHT),                        (int) (y + (srcPic.height() - y) * PADDING_TOP_BOTTOM),                        (int) (srcPic.width() * (1 - PADDING_LEFT_RIGHT * 2)),                        (int) ((srcPic.height() - y) * (1 - PADDING_TOP_BOTTOM * 2)));            }            //cut the source picture to cutMat            Mat cutMat = new Mat(srcPic, rect);            blockImages.add(cutMat);        }    }    /**     * cut the rows in blockImages to cols     */    private void cutImageToCols() {        for (int position = 0; position < blockImages.size(); position++) {            Mat image = blockImages.get(position);            //dilate much to find all lines            dilateMuchPic = new Mat();            Mat kernelDilateMuch = Imgproc.getStructuringElement(Imgproc.MORPH_DILATE, new Size(6, 6));            Imgproc.dilate(image, dilateMuchPic, kernelDilateMuch);            //find lines            Mat lines = new Mat();            Imgproc.HoughLinesP(dilateMuchPic, lines, 0.1, Math.PI / 360, X_THRESHOLD,                    image.height() * X_HEIGHT_FACTOR, X_MAXLINEGAP);            ArrayList<Double> lineXs = new ArrayList<>();            for (int i = 0; i < lines.rows(); i++) {                double[] points = lines.get(i, 0);                double x1, x2;                x1 = points[0];                x2 = points[2];                if (Math.abs(x1 - x2) < 50) {                    lineXs.add((((x1 + x2) / 2)));//store the x-coordinate                }            }            ArrayList<Double> uniqueLineXs = new ArrayList<>();            getUniqueLines(lineXs, uniqueLineXs, 10);            //filter the invalid lines            ArrayList<Double> betterLineXs = new ArrayList<>();            filterLines(uniqueLineXs, betterLineXs, image.width());            //filter the image that have too much or too less lines or too small height            if (betterLineXs.size() < 2 || betterLineXs.size() > 5 || image.height() < srcPic.height() * 0.015) {                continue;            }            //find a valid image            colNum++;            cutImages(betterLineXs, image);        }    }    /**     * filter the source coordinates, if some values are too close ,get the average of them     *     * @param src    source coordinates list     * @param dst    destination coordinate list     * @param minGap the minimum gap between coordinates     */    private void getUniqueLines(ArrayList<Double> src, ArrayList<Double> dst, int minGap) {        Collections.sort(src); //sort the source coordinates list        for (int i = 0; i < src.size(); i++) {            double sum = src.get(i);            double num = 1;            //when the distance between lines less than minGap, get the average of them            while (i != src.size() - 1 && src.get(i + 1) - src.get(i) < minGap) {                num++;                sum = sum + src.get(i + 1);                i++;            }            if (num == 1) {                dst.add(src.get(i));            } else {                dst.add(((sum / num)));            }        }    }    /**     * get the left and right bounds of some continuous lines     *     * @param src         source of coordinates list     * @param dst         destination of coordinates list, the bound will be stored like (start - end - start - end ...)     * @param maxGap      the maximum gap between adjacent lines that can be considered as continuous lines     * @param minDistance the minimum distance between start bound and end bound     */    private void getBounds(ArrayList<Double> src, ArrayList<Double> dst, int maxGap, int minDistance) {        Collections.sort(src);        for (int i = 0; i < src.size(); i++) {            double start = src.get(i);            double end = src.get(i);            //when the distance between two lines less than 10,get the average of them            while (i != src.size() - 1 && src.get(i + 1) - src.get(i) < maxGap) {                end = src.get(i + 1);                i++;            }            if (end - start >= minDistance) {                dst.add(start);                dst.add(end);            }        }    }    /**     * if the gap between lines less than filterGap*width, reserve the first of them and filter out others     *     * @param src   source coordinates list     * @param dst   destination coordinates list     * @param width the width of image     */    private void filterLines(ArrayList<Double> src, ArrayList<Double> dst, int width) {        for (int i = 0; i < src.size(); i++) {            int recode = i;            while (i != src.size() - 1 && src.get(i + 1) - src.get(i) <                    width * tableInfo.getRows(colNum + 1).getFilterGap()) {                i++;            }            dst.add(src.get(recode));        }    }    /**     * cut the rows to cells     *     * @param lineXs the x-coordinates list represents lines,     *               the content between start bound and end bound will be cut and passed on to next step     * @param image  the rows to be cut     */    private void cutImages(ArrayList<Double> lineXs, Mat image) {        Mat cutMat = new Mat(image, new Rect((int)(lineXs.get(tableInfo.getRows(colNum).getBoundLeft()) + 5),                0,                (int)(lineXs.get(tableInfo.getRows(colNum).getBoundRight()) -                        lineXs.get(tableInfo.getRows(colNum).getBoundLeft())) - 10, image.height()));        mats.add(cutSingleLine(cutMat));    }    /**     * cut the content of cells to single lines     * @param srcMat source image to be cut     * @return single lines,every single line include single characters or just lines(when the content is number)     */    private ArrayList<ArrayList<Mat>> cutSingleLine(Mat srcMat) {        ArrayList<ArrayList<Mat>> singleLines = new ArrayList<>();        //store the y-coordinates of empty rows (which has few white pixel)        ArrayList<Double> emptyRows = new ArrayList<>();        ArrayList<Double> uniqueEmptyRows = new ArrayList<>();        //walking all of pixels of each rows, when the count of white pixels less than 3, store the y-coordinate of row        double[] points;        for (int row = 0; row < srcMat.rows(); row++) {            int count = 0;            for (int col = 0; col < srcMat.cols(); col++) {                points = srcMat.get(row, col);                if (points[0] == 255) {                    count++;                }            }            if (count < 3) emptyRows.add((double)row);        }        getUniqueLines(emptyRows, uniqueEmptyRows, 10);        //if the start bound or end bound are not found because of the slope table bound, add them manually        if (uniqueEmptyRows.get(0) > srcMat.height() * 0.3)            uniqueEmptyRows.add(0, 0.0);        if (uniqueEmptyRows.get(uniqueEmptyRows.size() - 1) < srcMat.height() * 0.7)            uniqueEmptyRows.add((double)(srcMat.height() - 1));        ArrayList<Mat> linesInCol = new ArrayList<>();        for (int i = 0; i < uniqueEmptyRows.size(); i++) {            if (i != uniqueEmptyRows.size() - 1) {                Mat cutMat = new Mat(srcMat, new Rect(0,                        ( uniqueEmptyRows.get(i).intValue()),                        srcMat.width(),                        (((int) (uniqueEmptyRows.get(i + 1) - uniqueEmptyRows.get(i))))));                if (singleLineMode || tableInfo.getRows(colNum).getDataType() <= 1) {                    linesInCol.add(cutMat);                } else {                    singleLines.add(cutSingleCha(cutMat));                }            }        }        if (singleLineMode || tableInfo.getRows(colNum).getDataType() <= 1) singleLines.add(linesInCol);        return singleLines;    }    private ArrayList<Mat> cutSingleCha(Mat srcMat) {        ArrayList<Mat> characters = new ArrayList<>();        ArrayList<Double> emptyCols = new ArrayList<>();        ArrayList<Double> uniqueEmptyCols = new ArrayList<>();        double[] points;        for (int col = 0; col < srcMat.cols(); col++) {            int count = 0;            for (int row = 0; row < srcMat.rows(); row++) {                points = srcMat.get(row, col);                if (points[0] == 255) {                    count++;                }            }            if (count < 3) emptyCols.add((double) col);        }        getBounds(emptyCols, uniqueEmptyCols, 5, 2);        for (int i = 1; i < uniqueEmptyCols.size() - 1; i += 2) {            Mat cutMat = new Mat();            if (i < uniqueEmptyCols.size() - 3) {                if (uniqueEmptyCols.get(i + 1) - uniqueEmptyCols.get(i) < 40 &&                        uniqueEmptyCols.get(i + 3) - uniqueEmptyCols.get(i) < 55                        ) {                    cutMat = new Mat(srcMat, new Rect(uniqueEmptyCols.get(i).intValue(),                            0,                            (int) (uniqueEmptyCols.get(i + 3) - uniqueEmptyCols.get(i)),                            srcMat.height()));                    i += 2;                } else {                    cutMat = new Mat(srcMat, new Rect(uniqueEmptyCols.get(i).intValue(),                            0,                            (int) (uniqueEmptyCols.get(i + 1) - uniqueEmptyCols.get(i)),                            srcMat.height()));                }            } else if (i != uniqueEmptyCols.size() - 1) {                cutMat = new Mat(srcMat, new Rect(uniqueEmptyCols.get(i).intValue(),                        0,                        (int) (uniqueEmptyCols.get(i + 1) - uniqueEmptyCols.get(i)),                        srcMat.height()));            }            characters.add(cutMat);        }        return characters;    }    private BufferedImage convertMatToBufferedImage(Mat mat) {        BufferedImage bufferedImage = new BufferedImage(mat.width(), mat.height(), BufferedImage.TYPE_BYTE_GRAY);        byte[] data = ((DataBufferByte) bufferedImage.getRaster().getDataBuffer()).getData();        mat.get(0, 0, data);        return bufferedImage;    }    private void convertMatsToBufferedImages() {        for (int colId = 0; colId < tableInfo.getRowsSize(); colId++) {            ArrayList<ArrayList<Mat>> col = mats.get(colId);            ArrayList<BufferedImage> characters = new ArrayList<>();            for (ArrayList<Mat> singleLine : col) {                for (Mat character : singleLine) {                    BufferedImage bufferedImage = convertMatToBufferedImage(character);                    characters.add(bufferedImage);                }            }            tableInfo.getRows(colId).setBufferedImages(characters);        }    }}